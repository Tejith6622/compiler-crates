use std::fmt;

use pest::error::Error;
use pest::iterators::{Pair, Pairs};
use pest::pratt_parser::{Assoc, Op, PrattParser};
use pest::Parser;
use pest_derive::Parser;
use thiserror::Error;

#[derive(Parser)]
#[grammar = "grammar.pest"]
pub struct GrammarParser;

// Rule enum is automatically generated by pest_derive

// ===== ERROR HANDLING =====

#[derive(Error, Debug)]
pub enum ParseError {
    #[error("Pest parsing error: {0}")]
    Pest(#[from] Box<Error<Rule>>),
    #[error("Invalid number format: {0}")]
    InvalidNumber(String),
    #[error("Unknown operator: {0}")]
    UnknownOperator(String),
    #[error("Invalid JSON value")]
    InvalidJson,
    #[error("Unexpected end of input")]
    UnexpectedEOF,
}

pub type Result<T> = std::result::Result<T, ParseError>;

// ===== EXPRESSION AST =====

#[derive(Debug, Clone, PartialEq)]
pub enum Expr {
    Number(f64),
    Identifier(String),
    BinOp {
        left: Box<Expr>,
        op: BinOperator,
        right: Box<Expr>,
    },
}

#[derive(Debug, Clone, PartialEq)]
pub enum BinOperator {
    Add,
    Subtract,
    Multiply,
    Divide,
    Power,
    Eq,
    Ne,
    Lt,
    Le,
    Gt,
    Ge,
}

impl fmt::Display for BinOperator {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            BinOperator::Add => write!(f, "+"),
            BinOperator::Subtract => write!(f, "-"),
            BinOperator::Multiply => write!(f, "*"),
            BinOperator::Divide => write!(f, "/"),
            BinOperator::Power => write!(f, "^"),
            BinOperator::Eq => write!(f, "=="),
            BinOperator::Ne => write!(f, "!="),
            BinOperator::Lt => write!(f, "<"),
            BinOperator::Le => write!(f, "<="),
            BinOperator::Gt => write!(f, ">"),
            BinOperator::Ge => write!(f, ">="),
        }
    }
}

// ===== JSON AST =====

#[derive(Debug, Clone, PartialEq)]
pub enum JsonValue {
    Object(Vec<(String, JsonValue)>),
    Array(Vec<JsonValue>),
    String(String),
    Number(f64),
    Boolean(bool),
    Null,
}

// ===== PROGRAMMING LANGUAGE AST =====

#[derive(Debug, Clone, PartialEq)]
pub struct Program {
    pub statements: Vec<Statement>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum Statement {
    If {
        condition: Expr,
        then_block: Vec<Statement>,
        else_block: Option<Vec<Statement>>,
    },
    While {
        condition: Expr,
        body: Vec<Statement>,
    },
    Function {
        name: String,
        parameters: Vec<Parameter>,
        return_type: String,
        body: Vec<Statement>,
    },
    Assignment {
        name: String,
        value: Expr,
    },
    Expression(Expr),
    Block(Vec<Statement>),
}

#[derive(Debug, Clone, PartialEq)]
pub struct Parameter {
    pub name: String,
    pub type_name: String,
}

// ===== TOKEN TYPES =====

#[derive(Debug, Clone, PartialEq)]
pub enum Token {
    Keyword(String),
    Operator(String),
    Punctuation(String),
    Literal(LiteralValue),
    Identifier(String),
}

#[derive(Debug, Clone, PartialEq)]
pub enum LiteralValue {
    String(String),
    Number(f64),
    Boolean(bool),
}

// ===== EXPRESSION PARSER IMPLEMENTATION =====

impl GrammarParser {
    /// Parse an expression using pest's built-in precedence climbing
    pub fn parse_expression(input: &str) -> Result<Expr> {
        let pairs = Self::parse(Rule::expression, input).map_err(Box::new)?;
        Self::build_expression(pairs)
    }

    fn build_expression(pairs: Pairs<Rule>) -> Result<Expr> {
        let pratt = PrattParser::new()
            .op(Op::infix(Rule::eq, Assoc::Left) | Op::infix(Rule::ne, Assoc::Left))
            .op(Op::infix(Rule::lt, Assoc::Left)
                | Op::infix(Rule::le, Assoc::Left)
                | Op::infix(Rule::gt, Assoc::Left)
                | Op::infix(Rule::ge, Assoc::Left))
            .op(Op::infix(Rule::add, Assoc::Left) | Op::infix(Rule::subtract, Assoc::Left))
            .op(Op::infix(Rule::multiply, Assoc::Left) | Op::infix(Rule::divide, Assoc::Left))
            .op(Op::infix(Rule::power, Assoc::Right));

        pratt
            .map_primary(|primary| match primary.as_rule() {
                Rule::term => {
                    let inner = primary
                        .into_inner()
                        .next()
                        .ok_or(ParseError::UnexpectedEOF)?;
                    match inner.as_rule() {
                        Rule::number => {
                            let num = inner.as_str().parse::<f64>().map_err(|_| {
                                ParseError::InvalidNumber(inner.as_str().to_string())
                            })?;
                            Ok(Expr::Number(num))
                        }
                        Rule::identifier => Ok(Expr::Identifier(inner.as_str().to_string())),
                        Rule::expression => Self::build_expression(inner.into_inner()),
                        _ => unreachable!("Unexpected term rule: {:?}", inner.as_rule()),
                    }
                }
                Rule::number => {
                    let num = primary
                        .as_str()
                        .parse::<f64>()
                        .map_err(|_| ParseError::InvalidNumber(primary.as_str().to_string()))?;
                    Ok(Expr::Number(num))
                }
                Rule::identifier => Ok(Expr::Identifier(primary.as_str().to_string())),
                Rule::expression => Self::build_expression(primary.into_inner()),
                _ => unreachable!("Unexpected primary rule: {:?}", primary.as_rule()),
            })
            .map_infix(|left, op, right| {
                let op = match op.as_rule() {
                    Rule::add => BinOperator::Add,
                    Rule::subtract => BinOperator::Subtract,
                    Rule::multiply => BinOperator::Multiply,
                    Rule::divide => BinOperator::Divide,
                    Rule::power => BinOperator::Power,
                    Rule::eq => BinOperator::Eq,
                    Rule::ne => BinOperator::Ne,
                    Rule::lt => BinOperator::Lt,
                    Rule::le => BinOperator::Le,
                    Rule::gt => BinOperator::Gt,
                    Rule::ge => BinOperator::Ge,
                    _ => return Err(ParseError::UnknownOperator(op.as_str().to_string())),
                };
                Ok(Expr::BinOp {
                    left: Box::new(left?),
                    op,
                    right: Box::new(right?),
                })
            })
            .parse(pairs)
    }

    /// Parse a calculator expression with explicit precedence rules
    pub fn parse_calculation(input: &str) -> Result<f64> {
        let pairs = Self::parse(Rule::calculation, input).map_err(Box::new)?;
        Self::evaluate_calculation(
            pairs
                .into_iter()
                .next()
                .ok_or(ParseError::UnexpectedEOF)?
                .into_inner()
                .next()
                .ok_or(ParseError::UnexpectedEOF)?,
        )
    }

    fn evaluate_calculation(pair: Pair<Rule>) -> Result<f64> {
        match pair.as_rule() {
            Rule::calc_expression => {
                let mut pairs = pair.into_inner();
                let mut result =
                    Self::evaluate_calculation(pairs.next().ok_or(ParseError::UnexpectedEOF)?)?;

                while let (Some(op), Some(term)) = (pairs.next(), pairs.next()) {
                    let term_val = Self::evaluate_calculation(term)?;
                    match op.as_rule() {
                        Rule::calc_add_op => {
                            let inner_op =
                                op.into_inner().next().ok_or(ParseError::UnexpectedEOF)?;
                            match inner_op.as_rule() {
                                Rule::calc_plus => result += term_val,
                                Rule::calc_minus => result -= term_val,
                                _ => unreachable!("Unexpected add op: {:?}", inner_op.as_rule()),
                            }
                        }
                        Rule::calc_plus => result += term_val,
                        Rule::calc_minus => result -= term_val,
                        _ => unreachable!("Unexpected calc expression op: {:?}", op.as_rule()),
                    }
                }
                Ok(result)
            }
            Rule::calc_term => {
                let mut pairs = pair.into_inner();
                let mut result =
                    Self::evaluate_calculation(pairs.next().ok_or(ParseError::UnexpectedEOF)?)?;

                while let (Some(op), Some(factor)) = (pairs.next(), pairs.next()) {
                    let factor_val = Self::evaluate_calculation(factor)?;
                    match op.as_rule() {
                        Rule::calc_mul_op => {
                            let inner_op =
                                op.into_inner().next().ok_or(ParseError::UnexpectedEOF)?;
                            match inner_op.as_rule() {
                                Rule::calc_multiply => result *= factor_val,
                                Rule::calc_divide => result /= factor_val,
                                _ => unreachable!("Unexpected mul op: {:?}", inner_op.as_rule()),
                            }
                        }
                        Rule::calc_multiply => result *= factor_val,
                        Rule::calc_divide => result /= factor_val,
                        _ => unreachable!("Unexpected calc term op: {:?}", op.as_rule()),
                    }
                }
                Ok(result)
            }
            Rule::calc_factor => Self::evaluate_calculation(
                pair.into_inner().next().ok_or(ParseError::UnexpectedEOF)?,
            ),
            Rule::calc_power => {
                let mut pairs = pair.into_inner();
                let base =
                    Self::evaluate_calculation(pairs.next().ok_or(ParseError::UnexpectedEOF)?)?;

                if let Some(op) = pairs.next() {
                    if op.as_rule() == Rule::calc_pow_op {
                        let exponent = Self::evaluate_calculation(
                            pairs.next().ok_or(ParseError::UnexpectedEOF)?,
                        )?;
                        Ok(base.powf(exponent))
                    } else {
                        unreachable!("Expected calc_pow_op, got: {:?}", op.as_rule());
                    }
                } else {
                    Ok(base)
                }
            }
            Rule::calc_atom => Self::evaluate_calculation(
                pair.into_inner().next().ok_or(ParseError::UnexpectedEOF)?,
            ),
            Rule::calc_unary => {
                let mut pairs = pair.into_inner();
                let first = pairs.next().ok_or(ParseError::UnexpectedEOF)?;

                match first.as_rule() {
                    Rule::calc_minus => {
                        let val = Self::evaluate_calculation(
                            pairs.next().ok_or(ParseError::UnexpectedEOF)?,
                        )?;
                        Ok(-val)
                    }
                    Rule::calc_plus => {
                        let val = Self::evaluate_calculation(
                            pairs.next().ok_or(ParseError::UnexpectedEOF)?,
                        )?;
                        Ok(val)
                    }
                    Rule::calc_number => first
                        .as_str()
                        .parse::<f64>()
                        .map_err(|_| ParseError::InvalidNumber(first.as_str().to_string())),
                    _ => Self::evaluate_calculation(first),
                }
            }
            Rule::calc_number => pair
                .as_str()
                .parse::<f64>()
                .map_err(|_| ParseError::InvalidNumber(pair.as_str().to_string())),
            _ => unreachable!("Unexpected rule: {:?}", pair.as_rule()),
        }
    }
}

// ===== JSON PARSER IMPLEMENTATION =====

impl GrammarParser {
    /// Parse JSON input into a JsonValue AST
    pub fn parse_json(input: &str) -> Result<JsonValue> {
        let pairs = Self::parse(Rule::json_value, input).map_err(Box::new)?;
        Self::build_json_value(pairs.into_iter().next().ok_or(ParseError::UnexpectedEOF)?)
    }

    fn build_json_value(pair: Pair<Rule>) -> Result<JsonValue> {
        match pair.as_rule() {
            Rule::json_value => {
                Self::build_json_value(pair.into_inner().next().ok_or(ParseError::UnexpectedEOF)?)
            }
            Rule::object => {
                let mut object = Vec::new();
                for pair in pair.into_inner() {
                    if let Rule::pair = pair.as_rule() {
                        let mut inner = pair.into_inner();
                        let key =
                            Self::parse_string(inner.next().ok_or(ParseError::UnexpectedEOF)?)?;
                        let value =
                            Self::build_json_value(inner.next().ok_or(ParseError::UnexpectedEOF)?)?;
                        object.push((key, value));
                    }
                }
                Ok(JsonValue::Object(object))
            }
            Rule::array => {
                let mut array = Vec::new();
                for pair in pair.into_inner() {
                    array.push(Self::build_json_value(pair)?);
                }
                Ok(JsonValue::Array(array))
            }
            Rule::string => Ok(JsonValue::String(Self::parse_string(pair)?)),
            Rule::number => {
                let num = pair
                    .as_str()
                    .parse::<f64>()
                    .map_err(|_| ParseError::InvalidNumber(pair.as_str().to_string()))?;
                Ok(JsonValue::Number(num))
            }
            Rule::boolean => Ok(JsonValue::Boolean(pair.as_str() == "true")),
            Rule::null => Ok(JsonValue::Null),
            _ => Err(ParseError::InvalidJson),
        }
    }

    fn parse_string(pair: Pair<Rule>) -> Result<String> {
        let inner = pair.into_inner().next().ok_or(ParseError::UnexpectedEOF)?;
        Ok(inner.as_str().to_string())
    }
}

// ===== PROGRAMMING LANGUAGE PARSER =====

impl GrammarParser {
    /// Parse a complete program
    pub fn parse_program(input: &str) -> Result<Program> {
        let pairs = Self::parse(Rule::program, input).map_err(Box::new)?;
        let mut statements = Vec::new();

        for pair in pairs
            .into_iter()
            .next()
            .ok_or(ParseError::UnexpectedEOF)?
            .into_inner()
        {
            if pair.as_rule() != Rule::EOI {
                statements.push(Self::build_statement(pair)?);
            }
        }

        Ok(Program { statements })
    }

    fn build_statement(pair: Pair<Rule>) -> Result<Statement> {
        match pair.as_rule() {
            Rule::statement => {
                Self::build_statement(pair.into_inner().next().ok_or(ParseError::UnexpectedEOF)?)
            }
            Rule::if_statement => {
                let mut inner = pair.into_inner();
                let condition = Self::build_expression_from_pair(
                    inner.next().ok_or(ParseError::UnexpectedEOF)?,
                )?;
                let then_block = Self::build_block(inner.next().ok_or(ParseError::UnexpectedEOF)?)?;
                let else_block = inner
                    .next()
                    .map(|p| match p.as_rule() {
                        Rule::block => Self::build_block(p),
                        Rule::if_statement => Ok(vec![Self::build_statement(p)?]),
                        _ => unreachable!(),
                    })
                    .transpose()?;

                Ok(Statement::If {
                    condition,
                    then_block,
                    else_block,
                })
            }
            Rule::while_statement => {
                let mut inner = pair.into_inner();
                let condition = Self::build_expression_from_pair(
                    inner.next().ok_or(ParseError::UnexpectedEOF)?,
                )?;
                let body = Self::build_block(inner.next().ok_or(ParseError::UnexpectedEOF)?)?;

                Ok(Statement::While { condition, body })
            }
            Rule::function_def => {
                let mut inner = pair.into_inner();
                let name = inner
                    .next()
                    .ok_or(ParseError::UnexpectedEOF)?
                    .as_str()
                    .to_string();

                let mut parameters = Vec::new();
                let mut next = inner.next().ok_or(ParseError::UnexpectedEOF)?;

                if next.as_rule() == Rule::parameter_list {
                    for param_pair in next.into_inner() {
                        let mut param_inner = param_pair.into_inner();
                        let param_name = param_inner
                            .next()
                            .ok_or(ParseError::UnexpectedEOF)?
                            .as_str()
                            .to_string();
                        let param_type = param_inner
                            .next()
                            .ok_or(ParseError::UnexpectedEOF)?
                            .as_str()
                            .to_string();
                        parameters.push(Parameter {
                            name: param_name,
                            type_name: param_type,
                        });
                    }
                    next = inner.next().ok_or(ParseError::UnexpectedEOF)?;
                }

                let return_type = next.as_str().to_string();
                let body = Self::build_block(inner.next().ok_or(ParseError::UnexpectedEOF)?)?;

                Ok(Statement::Function {
                    name,
                    parameters,
                    return_type,
                    body,
                })
            }
            Rule::assignment => {
                let mut inner = pair.into_inner();
                let name = inner
                    .next()
                    .ok_or(ParseError::UnexpectedEOF)?
                    .as_str()
                    .to_string();
                let value = Self::build_expression_from_pair(
                    inner.next().ok_or(ParseError::UnexpectedEOF)?,
                )?;

                Ok(Statement::Assignment { name, value })
            }
            Rule::expression_statement => {
                let expr = Self::build_expression_from_pair(
                    pair.into_inner().next().ok_or(ParseError::UnexpectedEOF)?,
                )?;
                Ok(Statement::Expression(expr))
            }
            Rule::block => Ok(Statement::Block(Self::build_block(pair)?)),
            _ => unreachable!("Unexpected statement rule: {:?}", pair.as_rule()),
        }
    }

    fn build_block(pair: Pair<Rule>) -> Result<Vec<Statement>> {
        let mut statements = Vec::new();
        for stmt_pair in pair.into_inner() {
            statements.push(Self::build_statement(stmt_pair)?);
        }
        Ok(statements)
    }

    fn build_expression_from_pair(pair: Pair<Rule>) -> Result<Expr> {
        Self::build_expression(pair.into_inner())
    }
}

// ===== TOKEN PARSER =====

impl GrammarParser {
    /// Parse input into a stream of tokens
    pub fn parse_tokens(input: &str) -> Result<Vec<Token>> {
        let pairs = Self::parse(Rule::token_stream, input).map_err(Box::new)?;
        let mut tokens = Vec::new();

        for pair in pairs
            .into_iter()
            .next()
            .ok_or(ParseError::UnexpectedEOF)?
            .into_inner()
        {
            if pair.as_rule() != Rule::EOI {
                tokens.push(Self::build_token(pair)?);
            }
        }

        Ok(tokens)
    }

    fn build_token(pair: Pair<Rule>) -> Result<Token> {
        match pair.as_rule() {
            Rule::keyword => Ok(Token::Keyword(pair.as_str().to_string())),
            Rule::operator_token => Ok(Token::Operator(pair.as_str().to_string())),
            Rule::punctuation => Ok(Token::Punctuation(pair.as_str().to_string())),
            Rule::literal => {
                let inner = pair.into_inner().next().ok_or(ParseError::UnexpectedEOF)?;
                match inner.as_rule() {
                    Rule::string_literal => {
                        let content = inner
                            .into_inner()
                            .next()
                            .ok_or(ParseError::UnexpectedEOF)?
                            .as_str();
                        Ok(Token::Literal(LiteralValue::String(content.to_string())))
                    }
                    Rule::number_literal => {
                        let num = inner
                            .as_str()
                            .parse::<f64>()
                            .map_err(|_| ParseError::InvalidNumber(inner.as_str().to_string()))?;
                        Ok(Token::Literal(LiteralValue::Number(num)))
                    }
                    Rule::boolean_literal => Ok(Token::Literal(LiteralValue::Boolean(
                        inner.as_str() == "true",
                    ))),
                    _ => unreachable!(),
                }
            }
            Rule::identifier_token => Ok(Token::Identifier(pair.as_str().to_string())),
            _ => unreachable!("Unexpected token rule: {:?}", pair.as_rule()),
        }
    }
}

// ===== HELPER FUNCTIONS =====

impl GrammarParser {
    /// Parse and print pest parse tree for debugging
    pub fn debug_parse(rule: Rule, input: &str) -> Result<()> {
        let pairs = Self::parse(rule, input).map_err(Box::new)?;
        for pair in pairs {
            Self::print_pair(&pair, 0);
        }
        Ok(())
    }

    fn print_pair(pair: &Pair<Rule>, indent: usize) {
        let indent_str = "  ".repeat(indent);
        println!("{}{:?}: \"{}\"", indent_str, pair.as_rule(), pair.as_str());

        for inner_pair in pair.clone().into_inner() {
            Self::print_pair(&inner_pair, indent + 1);
        }
    }

    /// Extract all identifiers from an expression
    pub fn extract_identifiers(expr: &Expr) -> Vec<String> {
        match expr {
            Expr::Identifier(name) => vec![name.clone()],
            Expr::BinOp { left, right, .. } => {
                let mut ids = Self::extract_identifiers(left);
                ids.extend(Self::extract_identifiers(right));
                ids
            }
            Expr::Number(_) => vec![],
        }
    }

    /// Check if a rule matches the complete input
    pub fn can_parse(rule: Rule, input: &str) -> bool {
        match Self::parse(rule, input) {
            Ok(pairs) => {
                // Check that the entire input is consumed
                let input_len = input.len();
                let parsed_len = pairs.as_str().len();
                parsed_len == input_len
            }
            Err(_) => false,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_expression_parsing() {
        let expr = GrammarParser::parse_expression("2 + 3 * 4").unwrap();
        match expr {
            Expr::BinOp {
                op: BinOperator::Add,
                ..
            } => (),
            _ => panic!("Expected addition at top level"),
        }
    }

    #[test]
    fn test_calculation() {
        assert_eq!(GrammarParser::parse_calculation("2 + 3 * 4").unwrap(), 14.0);
        assert_eq!(
            GrammarParser::parse_calculation("(2 + 3) * 4").unwrap(),
            20.0
        );
        assert_eq!(
            GrammarParser::parse_calculation("2 ^ 3 ^ 2").unwrap(),
            512.0
        );
    }

    #[test]
    fn test_json_parsing() {
        let json = r#"{"name": "test", "value": 42, "active": true}"#;
        let result = GrammarParser::parse_json(json).unwrap();

        if let JsonValue::Object(obj) = result {
            assert_eq!(obj.len(), 3);
        } else {
            panic!("Expected JSON object");
        }
    }

    #[test]
    fn test_program_parsing() {
        let program = r#"
            fn add(x: int, y: int) -> int {
                x + y;
            }

            if x > 0 {
                y = 42;
            }
        "#;

        let result = GrammarParser::parse_program(program).unwrap();
        assert_eq!(result.statements.len(), 2);
    }

    #[test]
    fn test_token_parsing() {
        let input = "if x == 42 { return true; }";
        let tokens = GrammarParser::parse_tokens(input).unwrap();
        assert!(tokens.len() > 5);

        match &tokens[0] {
            Token::Keyword(kw) => assert_eq!(kw, "if"),
            _ => panic!("Expected keyword"),
        }
    }

    #[test]
    fn test_identifier_extraction() {
        let expr = GrammarParser::parse_expression("x + y * z").unwrap();
        let ids = GrammarParser::extract_identifiers(&expr);
        assert_eq!(ids, vec!["x", "y", "z"]);
    }

    #[test]
    fn test_debug_features() {
        assert!(GrammarParser::can_parse(Rule::expression, "2 + 3"));
        assert!(!GrammarParser::can_parse(Rule::expression, "2 +"));
    }
}
